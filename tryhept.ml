open Js_of_ocaml
open Js_of_ocaml_lwt
open Ezjs_ace

open Compiler_utils
open Compiler_options

let read_file filename =
  let lines = ref [] in
  let chan = open_in filename in
  try
    while true; do
      lines := input_line chan :: !lines
    done; !lines
  with End_of_file ->
    close_in chan;
    List.rev !lines

(* [modname] is the module name, [source_f] is the source file *)
let parse_program modname source =
  let lexbuf = Lexing.from_string source in

  (* Activates passes according to the backend used *)
  Mls2seq.load_conf ();
  (* Process the [lexbuf] to an Heptagon AST *)
  Hept_parser_scoper.parse_program modname lexbuf stdout

(* Check the program *)
let check_program p log_c =
  let pp p = if !verbose then Hept_printer.print log_c p in

  let p = silent_pass "Statefulness check" true Stateful.program p in
  let p = silent_pass "Unsafe check" true Unsafe.program p in
  let p = pass "Typing" true Typing.program p pp in
  let p = pass "Linear Typing" !do_linear_typing Linear_typing.program p pp in
  let p = pass "Inlining" true Inline.program p pp in
  let p = pass "Contracts" true Contracts.program p pp in
  let p = silent_pass "Causality check" !causality Causality.program p in
  let _ = silent_pass "Initialization check" !init Initialization.program p in
  ()

(* [modname] is the module name, [p] is the heptagon program *)
let compile_program modname p =

  let minils_c = open_out (modname^".mls") in
  let log_c = stdout in

  let close_all () =
    close_out minils_c
  in

  (try
     (* Process the Heptagon AST *)
     let p = Hept_compiler.compile_program p log_c in
     (* Compile Heptagon to MiniLS *)
     let p = Hept2mls.program p in
     (* Output the .mls *)
     Mls_printer.print minils_c p;
     (* Process the MiniLS AST *)
     let p = Mls_compiler.compile_program p log_c in
     (* Generate the sequential code *)
     Mls2seq.program p log_c;

   with e -> ());
  close_all ()

let reset_genv () =
  Modules.(
    g_env.current_mod <- Module "";
    g_env.opened_mod <- [];
    g_env.loaded_mod <- [];
    g_env.values <- Names.QualEnv.empty;
    g_env.types <- Names.QualEnv.empty;
    g_env.constrs <- Names.QualEnv.empty;
    g_env.fields <- Names.QualEnv.empty;
    g_env.consts <- Names.QualEnv.empty
  )

let prepare_module () =
  reset_genv ();

  let modname = "tryhept" in
  let modul = Names.modul_of_string modname in
  Initial.initialize modul;
  modname
  (* compile_program modname source *)

(** Show an error with [text] at [loc] in the console as well as the editor *)
let add_error_marker (editor : unit Ace.editor) (r1, r2) (c1, c2) =
  let open Ace in let open Ace_types in
  Printf.fprintf stdout "%d:%d, %d:%d\n" r1 c1 r2 c2;
  let range = Ace.range (r1-1) c1 (r2-1) c2 in
  ignore (editor.editor##getSession##addMarker range
            (Js.string "error-marker") (Js.string "text") (Js.bool true))

let parse_loc_message text =
  let reg = Str.regexp "File \"\", line \\([0-9]+\\)-?\\([0-9]+\\)?, characters \\([0-9]+\\)-\\([0-9]+\\):" in
  if not (Str.string_match reg text 0) then invalid_arg "parse_loc_message";
  let r1 = int_of_string (Str.matched_group 1 text) in
  let r2 = try int_of_string (Str.matched_group 2 text) with _ -> r1 in
  let c1 = int_of_string (Str.matched_group 3 text) and c2 = int_of_string (Str.matched_group 4 text) in
  (r1, r2), (c1, c2)

let print_error editor text =
  try
    let (row, col) = parse_loc_message text in
    add_error_marker editor row col
  with _ ->
    if text <> "\n" then Page.Console.error text

(** Read the fake file generated by printers *)
let read_file filename =
  let ch = open_in filename in
  let s = really_input_string ch (in_channel_length ch) in
  close_in ch;
  s

exception CompileError

(** Reset the editor *)
let reset_editor (editor: unit Ace.editor) =
  Ace.clear_marks editor;

  let markers = editor.editor##getSession##getMarkers (Js.bool true) in
  let markers = Js.Unsafe.global##._Object##keys markers in
  let markers = Js.to_array markers in
    Array.iter (fun m -> editor.editor##getSession##removeMarker m) markers;

  Page.Console.clear ()

(** Compile the program for visualisation purposes *)
let compile_and_exn editor step =
  reset_editor editor;

  try
    let modname = prepare_module () in
    let p = parse_program modname (Ace.get_contents editor) in
    check_program p stdout
  with e -> () (* print_error (Printexc.to_string e) *)

let compile_and_output editor (panel: Page.panel) =
  reset_editor editor;

  (try
     let modname = prepare_module () in
     let p = parse_program modname (Ace.get_contents editor) in
     compile_program modname p
   with e -> ());

  match panel.ptype with
  | Source -> ()
  | MiniLS ->
    Ace.set_contents panel.editor (read_file "tryhept.mls")
  | Obc ->
    Ace.set_contents panel.editor (read_file "tryhept.obc")

let (let*) = Lwt.bind
let (and*) = Lwt.both

let download_pervasives () =
  let* f = XmlHttpRequest.perform_raw ~response_type:ArrayBuffer "./pervasives.epci" in
  let s = Typed_array.String.of_arrayBuffer
      (Js.Opt.get f.content
         (fun _ -> failwith "Couldn't download pervasives.epci")) in

  let pervasives = open_out_bin "pervasives.epci" in
  output_string pervasives s;
  close_out pervasives;
  Lwt.return ()

let _ =
  let* _ = download_pervasives () in

  let editor_panel = Page.(create_panel Source
      [("+MiniLS", Button (fun () -> ignore (create_panel MiniLS [])));
       ("+Obc", Button (fun () -> ignore (create_panel Obc [])))
      ])
  in

  (* Direct error channel *)
  Sys_js.set_channel_flusher stderr (fun e -> print_error editor_panel.editor e);

  Page.add_panel_control editor_panel ("Compile", Page.Button (fun () ->
      try List.iter (fun p -> compile_and_output editor_panel.editor p) !Page.output_panels
      with _ -> ()
    ));
  editor_panel.editor.editor##on (Js.string "change") (fun () ->
      Page.save_program (Ace.get_contents editor_panel.editor);
      try compile_and_exn editor_panel.editor Page.Source
      with _ -> ());
  Ace.set_contents editor_panel.editor (Page.get_saved_program ());
  Lwt.return ()
