open Js_of_ocaml
open Js_of_ocaml_lwt
open Ezjs_ace

open Compiler_utils
open Compiler_options

open Interp

let read_file filename =
  let lines = ref [] in
  let chan = open_in filename in
  try
    while true; do
      lines := input_line chan :: !lines
    done; !lines
  with End_of_file ->
    close_in chan;
    List.rev !lines

(* [modname] is the module name, [source_f] is the source file *)
let parse_program modname source =
  let lexbuf = Lexing.from_string source in

  (* Activates passes according to the backend used *)
  Mls2seq.load_conf ();
  (* Process the [lexbuf] to an Heptagon AST *)
  Hept_parser_scoper.parse_program modname lexbuf stdout

(* Check the program *)
let check_program p log_c =
  let pp p = if !verbose then Hept_printer.print log_c p in

  let p = silent_pass "Statefulness check" true Stateful.program p in
  let p = silent_pass "Unsafe check" true Unsafe.program p in
  let p = pass "Typing" true Typing.program p pp in
  let p = pass "Linear Typing" !do_linear_typing Linear_typing.program p pp in
  let p = pass "Inlining" true Inline.program p pp in
  let p = pass "Contracts" true Contracts.program p pp in
  let p = silent_pass "Causality check" !causality Causality.program p in
  let _ = silent_pass "Initialization check" !init Initialization.program p in
  ()

(* [modname] is the module name, [p] is the heptagon program *)
let compile_program modname p =
  let minils_c = open_out (modname^".mls") in
  let log_c = stdout in

  let close_all () =
    close_out minils_c
  in

  (* Process the Heptagon AST *)
  let p = Hept_compiler.compile_program p log_c in
  (* Compile Heptagon to MiniLS *)
  let p = Hept2mls.program p in
  (* Output the .mls *)
  Mls_printer.print minils_c p;
  (* Process the MiniLS AST *)
  let p = Mls_compiler.compile_program p log_c in
  (* Compile MiniLS *)
  let p = Mls2obc.program p in
  let p = Obc_compiler.compile_program log_c p in
  Mls2seq.write_obc_file p;
  close_all (); p

let reset_genv () =
  Modules.(
    g_env.current_mod <- Module "";
    g_env.opened_mod <- [];
    g_env.loaded_mod <- [];
    g_env.values <- Names.QualEnv.empty;
    g_env.types <- Names.QualEnv.empty;
    g_env.constrs <- Names.QualEnv.empty;
    g_env.fields <- Names.QualEnv.empty;
    g_env.consts <- Names.QualEnv.empty
  )

let prepare_module () =
  reset_genv ();

  let modname = "tryhept" in
  let modul = Names.modul_of_string modname in
  Initial.initialize modul;
  modname
  (* compile_program modname source *)

(** Show an error with [text] at [loc] in the console as well as the editor *)
let add_error_marker (editor : unit Ace.editor) (r1, r2) (c1, c2) =
  let open Ace in let open Ace_types in
  Printf.fprintf stdout "%d:%d, %d:%d\n" r1 c1 r2 c2;
  let range = Ace.range (r1-1) c1 (r2-1) c2 in
  ignore (editor.editor##getSession##addMarker range
            (Js.string "error-marker") (Js.string "text") (Js.bool true))

let parse_loc_message text =
  let reg = Str.regexp "File \"\", line \\([0-9]+\\)-?\\([0-9]+\\)?, characters \\([0-9]+\\)-\\([0-9]+\\):" in
  if not (Str.string_match reg text 0) then invalid_arg "parse_loc_message";
  let r1 = int_of_string (Str.matched_group 1 text) in
  let r2 = try int_of_string (Str.matched_group 2 text) with _ -> r1 in
  let c1 = int_of_string (Str.matched_group 3 text) and c2 = int_of_string (Str.matched_group 4 text) in
  (r1, r2), (c1, c2)

let print_error editor text =
  try
    let (row, col) = parse_loc_message text in
    add_error_marker editor row col
  with _ ->
    if text <> "\n" then Page.Console.error text

(** Read the fake file generated by printers *)
let read_file filename =
  let ch = open_in filename in
  let s = really_input_string ch (in_channel_length ch) in
  close_in ch;
  s

exception CompileError

(** Reset the editor *)
let reset_editor (editor: unit Ace.editor) =
  Ace.clear_marks editor;

  let markers = editor.editor##getSession##getMarkers (Js.bool true) in
  let markers = Js.Unsafe.global##._Object##keys markers in
  let markers = Js.to_array markers in
    Array.iter (fun m -> editor.editor##getSession##removeMarker m) markers;

  Page.Console.clear ()

(** Compile the program for visualisation purposes *)
let compile_and_exn editor =
  reset_editor editor;

  try
    let modname = prepare_module () in
    let p = parse_program modname (Ace.get_contents editor) in
    check_program p stdout
  with e -> () (* print_error (Printexc.to_string e) *)

let get_loaded_file () = Page.get_string_from_storage "loaded"
let save_loaded_file s = Page.save_string_in_storage "loaded" s

let loaded_file = ref (match get_loaded_file () with Some s -> s | None -> "")

let compile_and_output editor (panel: Page.panel) =
  reset_editor editor;

  let modname = prepare_module () in
  let p = parse_program modname (Ace.get_contents editor) in
  let p = compile_program modname p in

  match panel with
  | AcePanel (id, panel) ->
    (match panel.ptype with
     | Source -> ()
     | MiniLS ->
       Ace.set_contents panel.editor (read_file "tryhept.mls")
     | Obc ->
       Ace.set_contents panel.editor (read_file "tryhept.obc")
     | _ -> invalid_arg "compile_and_output"
    )
  | InterpPanel id ->
    Interp.load_interp id p (interpreter_of_example !loaded_file p)

let (let*) = Lwt.bind
let (and*) = Lwt.both

let download_pervasives () =
  let outf = open_out_bin "pervasives.epci" in
  List.iter (output_byte outf) Pervasives.pervasives;
  close_out outf;
  Lwt.return ()

let download_mathlib () =
  let outf = open_out_bin "mathlib.epci" in
  List.iter (output_byte outf) Mathlib.mathlib;
  close_out outf;
  Lwt.return ()

let set_loaded_file s =
  save_loaded_file s;
  loaded_file := s

let save_program s =
  Page.save_string_in_storage !loaded_file s

let load_program () =
  match Page.get_string_from_storage !loaded_file with
  | Some s -> s
  | None -> "(* Your code here... *)"

let load_example editor name content =
  set_loaded_file name;
  let content =
    match Page.get_string_from_storage name with
    | Some s -> s
    | None -> content
  in
  Ace.set_contents editor content;
  (* load interpreter *)
  Page.clear_panels ();
  ignore Page.(create_panel Interpreter [])

let _ =
  let* _ = download_pervasives () in
  let* _ = download_mathlib () in

  let editor_panel = Page.(create_panel Source []) in
  let editor_panel = match editor_panel with AcePanel (_, panel) -> panel | _ -> failwith "Not Good" in
  let editor = editor_panel.editor in

  (* Direct error channel *)
  Sys_js.set_channel_flusher stderr (fun e -> print_error editor_panel.editor e);

  (* Compilation function *)
  let compile () =
    try
      compile_and_exn editor_panel.editor;
      List.iter (fun p -> compile_and_output editor_panel.editor p) !Page.output_panels
    with _ -> ()
  in

  Page.add_examples (fun name content -> load_example editor name content; compile ());

  (* Page.add_panel_control editor_panel ("+MiniLS", Button (fun () -> ignore Page.(create_panel MiniLS []); compile ())); *)

  (* Page.add_panel_control editor_panel *)
  (*   ("+Interp Chrono", *)
  (*    Button (fun () -> ignore Page.(create_panel (Interpreter Table) []); compile ())); *)
  editor.editor##on (Js.string "change") (fun () ->
      save_program (Ace.get_contents editor);
      compile ());
  load_example editor !loaded_file (load_program ());
  ignore Page.(create_panel Obc []); (* TEMP *)
  compile ();
  Lwt.return ()
