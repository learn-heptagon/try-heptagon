open Js_of_ocaml
open Js_of_ocaml_lwt
open Ezjs_ace

open Compiler_utils
open Compiler_options

(* [modname] is the module name, [source_f] is the source file *)
let compile_program modname source =

  let lexbuf = Lexing.from_string source in

  let log_c = stdout in

  try
    (* Activates passes according to the backend used *)
    Mls2seq.load_conf ();
    (* Process the [lexbuf] to an Heptagon AST *)
    let p = Hept_parser_scoper.parse_program modname lexbuf log_c in
    (* Process the Heptagon AST *)
    let p = Hept_compiler.compile_program p log_c in
    (* Compile Heptagon to MiniLS *)
    let p = do_pass "Translation into MiniLS"
        Hept2mls.program p (Mls_compiler.pp log_c) in
    (* (\* Output the .mls *\) *)
    (*   do_silent_pass "MiniLS serialization" (fun () -> Mls_printer.print mls_c p) (); *)
    (* Process the MiniLS AST *)
    let p = Mls_compiler.compile_program p log_c in
    (* Generate the sequential code *)
    Mls2seq.program p log_c;

    (* close_out log_c; *)
  with e -> raise e (* close_out log_c; raise e *)

let reinit_genv () =
  Modules.(
    g_env.current_mod <- Module "";
    g_env.opened_mod <- [];
    g_env.loaded_mod <- [];
    g_env.values <- Names.QualEnv.empty;
    g_env.types <- Names.QualEnv.empty;
    g_env.constrs <- Names.QualEnv.empty;
    g_env.fields <- Names.QualEnv.empty;
    g_env.consts <- Names.QualEnv.empty
  )

let compile source =
  reinit_genv ();

  let modname = "tryheptc" in
  let modul = Names.modul_of_string modname in
  Initial.initialize modul;
  compile_program modname source

(** Show an error with [text] at [loc] in the console as well as the editor *)
(* let show_error editor ?(in_console=false) text loc = *)
(*   if in_console then *)
(*     Page.Console.error (Printf.sprintf "%s at %s" text (Lexing.string_of_loc loc)); *)

(*   let s_row = loc.ast_lnum and s_col = loc.ast_cnum in *)

(*   Ace.set_mark *)
(*     ~type_:Ace.Error *)
(*     ~loc:{ loc_start = (s_row, s_col); loc_end = (s_row, s_col) } *)
(*     editor text *)

let print_error text =
  if text <> "\n" then Page.Console.error text

(** Incremental parser to reparse the token stream and generate an
    error message (the verified and extracted parser does not
    generate error messages). Adapted directly from menhir's
    calc-incremental example. *)

(** Read the fake file generated by printers *)
let read_file filename =
  let ch = open_in filename in
  let s = really_input_string ch (in_channel_length ch) in
  close_in ch;
  s

exception CompileError

(** Compile the program for visualisation purposes *)
let compile_and_exn editor ?(in_console=false) step =
  (* Reset markers *)
  Ace.clear_marks editor;

  try
    compile (Ace.get_contents editor)
  with e -> () (* print_error (Printexc.to_string e) *)

  (* (try *)
  (*    (lex_and_parse_program editor ~in_console () *)
  (*     |> (fun decls -> *)
  (*         if step = Page.Source then raise Veluslib.Done; *)
  (*         match Velus.compile decls (get_main_node decls) with *)
  (*         | Error errmsg -> *)
  (*           Format.fprintf Format.str_formatter "%a\n" Driveraux.print_error errmsg; *)
  (*           print_error (Format.flush_str_formatter ()); *)
  (*           raise CompileError *)
  (*         | OK _ -> ())); *)
  (*  with *)
  (*  | Veluslib.Done -> ()) *)

let compile_and_output editor panel =
  (* Reset destinations *)
  (* Veluslib.reset_config (); *)

  (* Page.(match panel.ptype with *)
  (*     | Source -> () *)
  (*     | NoLast -> Veluslib.nolast_destination := Some "out" *)
  (*     | NoSwitch -> Veluslib.noswitch_destination := Some "out" *)
  (*     | NoLocal -> Veluslib.nolocal_destination := Some "out" *)
  (*     | Lustre -> Veluslib.lustre_destination := Some "out" *)
  (*     | NLustre -> *)
  (*       Veluslib.nlustre_destination := Some "out"; *)
  (*       Veluslib.dce := get_checkbox_value "Dead Code Elimination" panel.controls; *)
  (*       Veluslib.dupregrem := get_checkbox_value "Remove Duplicate Registers" panel.controls *)
  (*     | Stc -> *)
  (*       if (get_checkbox_value "Schedule" panel.controls) *)
  (*       then Veluslib.sch_destination := Some "out" *)
  (*       else Veluslib.stc_destination := Some "out" *)
  (*     | Obc -> *)
  (*       Veluslib.obc_destination := Some "out"; *)
  (*       Veluslib.fuse_obc := get_checkbox_value "Fusion" panel.controls; *)
  (*       Veluslib.normalize_switches := get_checkbox_value "Normalize Switches" panel.controls *)
  (*     | Clight -> PrintClight.destination := Some "out" *)
  (*   ); *)

  compile_and_exn editor ~in_console:true Page.(panel.ptype);
  Ace.set_contents panel.editor (read_file "out")

let (let*) = Lwt.bind
let (and*) = Lwt.both

let download_pervasives () =
  let* f = XmlHttpRequest.perform_raw ~response_type:ArrayBuffer "./pervasives.epci" in
  let s = Typed_array.String.of_arrayBuffer
      (Js.Opt.get f.content
         (fun _ -> failwith "Couldn't download pervasives.epci")) in

  let pervasives = open_out_bin "pervasives.epci" in
  output_string pervasives s;
  close_out pervasives;
  Lwt.return ()

let _ =
  (* Direct error channel *)
  Sys_js.set_channel_flusher stderr (fun e -> print_error e);

  let* _ = download_pervasives () in

  (* add_target_language "obc"; *)

  let editor_panel = Page.(create_panel Source
      [("+Mls", Button (fun () -> ignore (create_panel Lustre [])));
       ("+Obc", Button (fun () -> ignore (create_panel Clight [])))
      ])
  in
  Page.add_panel_control editor_panel ("Compile", Page.Button (fun () ->
      try List.iter (fun p -> compile_and_output editor_panel.editor p) !Page.output_panels
      with _ -> ()
    ));
  editor_panel.editor.editor##on (Js.string "change") (fun () ->
      Page.save_program (Ace.get_contents editor_panel.editor);
      try compile_and_exn editor_panel.editor Page.Source
      with _ -> ());
  Ace.set_contents editor_panel.editor (Page.get_saved_program ());
  Lwt.return ()
